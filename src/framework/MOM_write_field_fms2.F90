!> This module contains wrapper functions to write data to netcdf files
module MOM_write_field_fms2

! This file is part of MOM6. See LICENSE.md for the license.


use MOM_axis,             only : MOM_get_diagnostic_axis_data, MOM_register_diagnostic_axis
use MOM_axis,             only : axis_data_type, get_time_index, get_var_dimension_metadata
use MOM_axis,             only : get_time_units, convert_checksum_to_string
use MOM_error_handler,    only : MOM_error, NOTE, FATAL, WARNING
use MOM_domains,          only : MOM_domain_type
use MOM_domains,          only : get_simple_array_i_ind, get_simple_array_j_ind
use MOM_grid,             only : ocean_grid_type
use MOM_dyn_horgrid,      only : dyn_horgrid_type
use MOM_string_functions, only : lowercase, append_substring
use MOM_verticalGrid,     only : verticalGrid_type
use mpp_mod,              only : mpp_pe, mpp_npes
use mpp_domains_mod,      only : domain2d
use mpp_domains_mod,      only : CENTER, CORNER, NORTH_FACE=>NORTH, EAST_FACE=>EAST
use mpp_domains_mod,      only : mpp_get_domain_npes, mpp_define_io_domain, mpp_get_io_domain
use netcdf
! fms2_io
use fms2_io_mod,          only : check_if_open, get_dimension_size
use fms2_io_mod,          only : get_num_dimensions,  get_num_variables, get_variable_names
use fms2_io_mod,          only : get_unlimited_dimension_name, get_variable_dimension_names
use fms2_io_mod,          only : get_variable_num_dimensions, get_variable_size, get_variable_units
use fms2_io_mod,          only : get_variable_unlimited_dimension_index, is_dimension_unlimited
use fms2_io_mod,          only : is_dimension_registered, register_axis
use fms2_io_mod,          only : register_field, register_variable_attribute, fms2_open_file => open_file
use fms2_io_mod,          only : fms2_close_file => close_file, write_data, variable_exists
use fms2_io_mod,          only : FmsNetcdfDomainFile_t, FmsNetcdfFile_t, unlimited

implicit none; private

public write_field

! CAUTION: The following variables are saved by default, and are only necessary for consecutive calls to
! write_field with the same file name. The user should ensure that fms2_close_file on
! the fileobj_write_field structures are called at every requisite time step at after the last
! variable is written to the file by omitting the optional leave_file_open argument, or setting it to .false.

!> netCDF non-domain-decomposed file object returned by call to open_file in write_field calls
type(FmsNetcdfFile_t), private :: fileobj_write_field

!> netCDF domain-decomposed file object returned by call to open_file in write_field calls
type(FmsNetcdfDomainFile_t), private :: fileobj_write_field_dd

!> index of the time_level value that is written to netCDF file by the write_field routines
integer, private :: write_field_time_index

!> interface to write data to a netcdf file generated by create_file
interface write_field
  module procedure write_field_4d_DD
  module procedure write_field_3d_DD
  module procedure write_field_2d_DD
  module procedure write_field_1d_DD
  module procedure write_scalar
  module procedure write_field_4d_noDD
  module procedure write_field_3d_noDD
  module procedure write_field_2d_noDD
  module procedure write_field_1d_noDD
end interface

!> interface to apply a scale factor to an array after reading in a field
interface scale_data
  module procedure scale_data_4d
  module procedure scale_data_3d
  module procedure scale_data_2d
  module procedure scale_data_1d
end interface

contains
!> This function uses the fms_io function write_data to write a 1-D domain-decomposed data field named "fieldname"
!! to the file "filename" in "write", "overwrite", or "append" mode. It should be called after create_file in the MOM
!! file write procedure.
subroutine write_field_1d_DD(filename, fieldname, data, mode, domain, hor_grid, z_grid, &
                             start_index, edge_lengths, time_level, time_units, scale, &
                             checksums, G, dG, GV, leave_file_open, units, longname)
  character(len=*), intent(in) :: filename !< The name of the file to read
  character(len=*), intent(in) :: fieldname !< The variable name of the data in the file
  real, target, dimension(:), intent(in) :: data !< The 1-dimensional data array to pass to read_data
  character(len=*), intent(in) :: mode !< "write", "overwrite", or "append"
  type(MOM_domain_type),intent(in) :: domain !< MOM domain attribute with the mpp_domain decomposition
  character(len=*), intent(in) :: hor_grid !< horizontal grid descriptor
  character(len=*), intent(in) :: z_grid !< vertical grid descriptor
  integer, dimension(1), optional, intent(in) :: start_index !< starting index of data buffer. Default is 1
  integer, dimension(1), optional, intent(in) :: edge_lengths !< number of data values to read in; default is
                                                              !! the variable size
  real, optional, intent(in) :: time_level !< time value to write
  real, optional, intent(in) :: time_units !< length of the units for time [s]. The
                                          !! default value is 86400.0, for 1 day.
  real, optional, intent(in) :: scale !< A scaling factor that the fields are multiplied by before they are written.
  integer(kind=8), dimension(:,:), optional, intent(in) :: checksums  !< variable checksum
  type(ocean_grid_type),   optional, intent(in) :: G !< ocean horizontal grid structure; G or dG
                                                     !! is required if the new file uses any
                                                     !! horizontal grid axes.
  type(dyn_horgrid_type),  optional, intent(in) :: dG !< dynamic horizontal grid structure; G or dG
                                                     !! is required if the new file uses any
                                                     !! horizontal grid axes.
  type(verticalGrid_type), optional, intent(in) :: GV !< ocean vertical grid structure, which is
                                                     !! required if the new file uses any
                                                     !! vertical grid axes.
  logical, optional, intent(in) :: leave_file_open !< if .true., leave the file open
  character(len=*), optional, intent(in) :: units !< variable units
  character(len=*), optional, intent(in) :: longname !< long name variable attribute
  ! local
  logical :: file_open_success !.true. if call to open_file is successful
  logical :: close_the_file ! indicates whether to close the file after write_data is called; default is .true.
  real, pointer, dimension(:) :: data_tmp => null() ! enables data to be passed to functions as intent(inout)
  integer :: num_dims, substring_index
  integer :: dim_unlim_size! size of the unlimited dimension
  integer, dimension(1) :: start, nwrite ! indices for first data value and number of values to write
  character(len=20) :: t_units ! time units
  character(len=nf90_max_name) :: dim_unlim_name ! name of the unlimited dimension in the file
  character(len=64) :: checksum_char ! checksum character array created from checksum argument
  character(len=1024) :: filename_temp
  character(len=48), dimension(2) :: dim_names !< variable dimension names (or name, in the 1-D case); 1 extra
                                               !! dimension in case appending along the time axis
  integer, dimension(2) :: dim_lengths !< variable dimension lengths (or length, in the 1-D case)

  close_the_file = .true.
  if (present(leave_file_open)) close_the_file = .not.(leave_file_open)

  dim_unlim_size=0
  dim_unlim_name=""
  dim_names(:) = ""
  dim_lengths(:) = 0
  num_dims = 0
  ! append '.nc' to the file name if it is missing
  filename_temp = ""
  substring_index = 0
  substring_index = index(trim(filename), ".nc")
  if (substring_index <= 0) then
    filename_temp = append_substring(filename,".nc")
  else
    filename_temp = filename
  endif
  ! get the dimension names and lengths
  ! NOTE: the t_grid argument is set to '1' (do nothing) because the presence of a time dimension is user-specified
  ! and not assumed from the t_grid value
  if (present(G)) then
      call get_var_dimension_metadata(hor_grid, z_grid, '1', dim_names, &
                                      dim_lengths, num_dims, G=G)
  elseif(present(dG)) then
      call get_var_dimension_metadata(hor_grid, z_grid, '1', dim_names, &
                                      dim_lengths, num_dims, dG=dG)
  endif

  if (present(GV)) &
  call get_var_dimension_metadata(hor_grid, z_grid, '1', dim_names, &
                                  dim_lengths, num_dims, GV=GV)
  ! define the start and edge_length arguments
  start(:) = 1
  nwrite(:) = dim_lengths(1)
  if (present(start_index)) then
    start(1) = max(1, start_index(1))
  endif

  if (present(edge_lengths)) then
    nwrite(1) = max(dim_lengths(1),edge_lengths(1))
  endif

  data_tmp => data
  ! scale the data
  if (present(scale)) then ; if (scale /= 1.0) then
    call scale_data(data_tmp,scale)
  endif ; endif

  if (.not.(check_if_open(fileobj_write_field_dd))) then
    if ((lowercase(trim(mode)) .ne. "write") .and. (lowercase(trim(mode)) .ne. "append") .and. &
        (lowercase(trim(mode)) .ne. "overwrite")) &
      call MOM_error(FATAL,"MOM_write_field_fms2:write_1d_DD:mode argument must be write, overwrite, or append")
    ! define the io domain for 1-pe jobs because it is required to write domain-decomposed files
    if (mpp_get_domain_npes(domain%mpp_domain) .eq. 1 ) then
      if (.not. associated(mpp_get_io_domain(domain%mpp_domain))) &
        call mpp_define_io_domain(domain%mpp_domain, (/1,1/))
    endif
    ! get the time_level index
    if (present(time_level)) write_field_time_index = get_time_index(trim(filename_temp), time_level)
    ! open the file in write or append mode
    file_open_success = fms2_open_file(fileobj_write_field_dd, trim(filename_temp), lowercase(trim(mode)), &
                                       domain%mpp_domain, is_restart=.false.)
    ! register the diagnostic axis associated with the variable
    call MOM_register_diagnostic_axis(fileobj_write_field_dd, trim(dim_names(1)), dim_lengths(1))
  endif
  ! register and write the time_level
  if (present(time_level)) then
    if (.not. (variable_exists(fileobj_write_field_dd, trim(dim_unlim_name)))) then
       ! set the time units
       t_units = ""
       if (present(time_units)) then
         t_units = get_time_units(time_units)
       else
         t_units = "days"
       endif

       call register_field(fileobj_write_field_dd, trim(dim_unlim_name), "double", dimensions=(/trim(dim_unlim_name)/))
       call register_variable_attribute(fileobj_write_field_dd, trim(dim_unlim_name), 'units', trim(t_units))
       call write_data(fileobj_write_field_dd, trim(dim_unlim_name), (/time_level/), corner=(/write_field_time_index/))
    else
      ! write the time_level if it is larger than the most recent file time
      if (write_field_time_index .gt. dim_unlim_size) &
        call write_data(fileobj_write_field_dd, trim(dim_unlim_name), (/time_level/), &
                        corner=(/write_field_time_index/), edge_lengths=(/1/))
    endif
  endif
  ! register the field if it is not already in the file
  if (.not.(variable_exists(fileobj_write_field_dd, trim(fieldname)))) then
    call register_field(fileobj_write_field_dd, trim(fieldname), "double", dimensions=dim_names(1:num_dims))
    if (present(units)) &
      call register_variable_attribute(fileobj_write_field_dd, trim(fieldname), 'units', trim(units))
    if (present(longname)) &
      call register_variable_attribute(fileobj_write_field_dd, trim(fieldname), 'long_name', trim(longname))
    ! write the checksum attribute
    if (present(checksums)) then
      ! convert the checksum to a string
      checksum_char = ""
      checksum_char = convert_checksum_to_string(checksums(1,1))
      call register_variable_attribute(fileobj_write_field_dd, trim(fieldname), "checksum", checksum_char)
    endif
  endif
  ! write the variable
  if (present(time_level)) then
    call write_data(fileobj_write_field_dd, trim(fieldname), data_tmp, corner=start, edge_lengths=nwrite, &
                    unlim_dim_level=write_field_time_index)
  else
    call write_data(fileobj_write_field_dd, trim(fieldname), data_tmp, corner=start, edge_lengths=nwrite)
  endif
  ! close the file
  if (close_the_file) then
    if (check_if_open(fileobj_write_field_dd)) call fms2_close_file(fileobj_write_field_dd)
    write_field_time_index = 0
  endif
  nullify(data_tmp)
end subroutine write_field_1d_DD

!> This function uses the fms_io function write_data to write a 2-D domain-decomposed data field named "fieldname"
!! to the file "filename" in "write", "overwrite", or "append" mode. It should be called after create_file in the MOM
!! file write procedure.
subroutine write_field_2d_DD(filename, fieldname, data, mode, domain, hor_grid, z_grid, &
                             start_index, edge_lengths, time_level, time_units, scale, &
                             checksums, G, dG, GV, leave_file_open, units, longname)
  character(len=*), intent(in) :: filename !< The name of the file to read
  character(len=*), intent(in) :: fieldname !< The variable name of the data in the file
  real, target, dimension(:,:), intent(in) :: data !< The 1-dimensional data array to pass to read_data
  character(len=*), intent(in) :: mode !< "write", "overwrite", or "append"
  type(MOM_domain_type),intent(in) :: domain !< MOM domain attribute with the mpp_domain decomposition
  character(len=*), intent(in) :: hor_grid !< horizontal grid descriptor
  character(len=*), intent(in) :: z_grid !< vertical grid descriptor
  integer, dimension(1), optional, intent(in) :: start_index !< starting index of data buffer. Default is 1
  integer, dimension(1), optional, intent(in) :: edge_lengths !< number of data values to read in; default is
                                                              !! the variable size
  real, optional, intent(in) :: time_level !< time value to write
  real, optional, intent(in) :: time_units !< length of the units for time [s]. The
                                          !! default value is 86400.0, for 1 day.
  real, optional, intent(in) :: scale !< A scaling factor that the fields are multiplied by before they are written.
  integer(kind=8), dimension(:,:), optional, intent(in) :: checksums  !< variable checksum
  type(ocean_grid_type),   optional, intent(in) :: G !< ocean horizontal grid structure; G or dG
                                                     !! is required if the new file uses any
                                                     !! horizontal grid axes.
  type(dyn_horgrid_type),  optional, intent(in) :: dG !< dynamic horizontal grid structure; G or dG
                                                     !! is required if the new file uses any
                                                     !! horizontal grid axes.
  type(verticalGrid_type), optional, intent(in) :: GV !< ocean vertical grid structure, which is
                                                     !! required if the new file uses any
                                                     !! vertical grid axes.
  logical, optional, intent(in) :: leave_file_open !< flag indicating whether to leave the file open
  character(len=*), optional, intent(in) :: units !< variable units
  character(len=*), optional, intent(in) :: longname !< long name variable attribute
  ! local
  logical :: file_open_success !.true. if call to open_file is successful
  logical :: close_the_file ! indicates whether to close the file after write_data is called; default is .true.
  real, pointer :: data_tmp(:,:) => null()
  integer :: i, is, ie, js, je, j, ndims, num_dims, substring_index
  integer, allocatable, dimension(:) :: x_inds, y_inds
  integer :: dim_unlim_size ! size of the unlimited dimension
  integer :: file_dim_length
  integer, dimension(2) :: start, nwrite ! indices for starting points and number of values to write
  character(len=20) :: t_units ! time units
  character(len=nf90_max_name) :: dim_unlim_name ! name of the unlimited dimension in the file
  character(len=1024) :: filename_temp
  character(len=64) :: checksum_char ! checksum character array created from checksum argument
  character(len=48), dimension(3) :: dim_names ! variable dimension names; 1 extra dimension in case appending
                                               ! along the time axis
  character(len=48), allocatable, dimension(:) :: file_dim_names
  integer, dimension(3) :: dim_lengths ! variable dimension lengths

  close_the_file = .true.
  if (present(leave_file_open)) close_the_file = .not.(leave_file_open)

  dim_lengths(:) = 0
  dim_names(:) = ""
  dim_unlim_size = 0
  dim_unlim_name = ""
  ndims = 2
  num_dims = 0
  ! append '.nc' to the file name if it is missing
  filename_temp = ""
  substring_index = 0
  substring_index = index(trim(filename), ".nc")
  if (substring_index <= 0) then
    filename_temp = append_substring(filename,".nc")
  else
    filename_temp = filename
  endif
  ! get the dimension names and lengths
  ! NOTE: the t_grid argument is set to '1' (do nothing) because the presence of a time dimension
  ! is user-specified rather than derived from the t_grid value
  if (present(G)) then
    call get_var_dimension_metadata(hor_grid, z_grid, '1', dim_names, &
                                    dim_lengths, num_dims, G=G)
  elseif(present(dG)) then
    call get_var_dimension_metadata(hor_grid, z_grid, '1', dim_names, &
                                    dim_lengths, num_dims, dG=dG)
  endif
  if (present(GV)) &
    call get_var_dimension_metadata(hor_grid, z_grid, '1', dim_names, &
                                    dim_lengths, num_dims, GV=GV)
  ! set the start (start_index) and nwrite (edge_lengths) values
  start(:) = 1
  nwrite(:) = dim_lengths(1:ndims)

  if (present(start_index)) then
    do i=1,ndims
      start(i) = max(1,start_index(i))
    enddo
  endif

  if (present(edge_lengths)) then
    do i=1,ndims
      nwrite(i) = max(dim_lengths(i),edge_lengths(i))
    enddo
  endif

  data_tmp => data
  ! scale the data
  if (present(scale)) then ; if (scale /= 1.0) then
    call scale_data(data_tmp,scale)
  endif ; endif

  if (.not.(check_if_open(fileobj_write_field_dd))) then
    if ((lowercase(trim(mode)) .ne. "write") .and. (lowercase(trim(mode)) .ne. "append") .and. &
        (lowercase(trim(mode)) .ne. "overwrite")) &
       call MOM_error(FATAL,"MOM_write_field_fms2:write_2d_DD:mode argument must be write, overwrite, or append")
    ! define the io domain for 1-pe jobs because it is required to write domain-decomposed files
    if (mpp_get_domain_npes(domain%mpp_domain) .eq. 1 ) then
      if (.not. associated(mpp_get_io_domain(domain%mpp_domain))) &
        call mpp_define_io_domain(domain%mpp_domain, (/1,1/))
    endif
    ! get the time_level index
    if (present(time_level)) write_field_time_index = get_time_index(trim(filename_temp), time_level)
    ! open the file in write or append mode
    file_open_success = fms2_open_file(fileobj_write_field_dd, trim(filename_temp), lowercase(trim(mode)), &
                                       domain%mpp_domain, is_restart=.false.)
  endif
  ! register the horizontal diagnostic axes associated with the variable
  do i=1,num_dims
    if (.not.(is_dimension_registered(fileobj_write_field_dd, trim(dim_names(i))))) &
      call MOM_register_diagnostic_axis(fileobj_write_field_dd, trim(dim_names(i)), dim_lengths(i))
  enddo
  ! register and write the time_level
  if (present(time_level)) then
    call get_unlimited_dimension_name(fileobj_write_field_dd, dim_unlim_name)
    call get_dimension_size(fileobj_write_field_dd, trim(dim_unlim_name), dim_unlim_size)
    num_dims=num_dims+1
    dim_names(num_dims) = trim(dim_unlim_name)

    if (.not. (variable_exists(fileobj_write_field_dd, trim(dim_unlim_name)))) then
       ! set the time units
       t_units = ""
       if (present(time_units)) then
         t_units = get_time_units(time_units)
       else
         t_units = "days"
       endif

       call register_field(fileobj_write_field_dd, trim(dim_unlim_name), "double", dimensions=(/trim(dim_unlim_name)/))
       call register_variable_attribute(fileobj_write_field_dd, trim(dim_unlim_name), 'units', trim(t_units))
       call write_data(fileobj_write_field_dd, trim(dim_unlim_name), (/time_level/), corner=(/write_field_time_index/))
    else
      ! write the time_level if it is larger than the most recent file time
      if (write_field_time_index .gt. dim_unlim_size) &
        call write_data(fileobj_write_field_dd, trim(dim_unlim_name), (/time_level/), &
                        corner=(/write_field_time_index/), edge_lengths=(/1/))
    endif
  endif
  ! register the variable if it is not already in the file
  if (.not.(variable_exists(fileobj_write_field_dd, trim(fieldname)))) then
    call register_field(fileobj_write_field_dd, trim(fieldname), "double", dimensions=dim_names(1:num_dims))
    if (present(units)) &
      call register_variable_attribute(fileobj_write_field_dd, trim(fieldname), 'units', trim(units))
    if (present(longname)) &
      call register_variable_attribute(fileobj_write_field_dd, trim(fieldname), 'long_name', trim(longname))
    ! write the checksum attribute
    if (present(checksums)) then
      ! convert the checksum to a string
      checksum_char = ""
      checksum_char = convert_checksum_to_string(checksums(1,1))
      call register_variable_attribute(fileobj_write_field_dd, trim(fieldname), "checksum", checksum_char)
    endif
  endif
  ! write the variable
  if (present(time_level)) then
    call write_data(fileobj_write_field_dd, trim(fieldname), data_tmp, corner=start, edge_lengths=nwrite, &
                    unlim_dim_level=write_field_time_index)
  else
    call write_data(fileobj_write_field_dd, trim(fieldname), data_tmp, corner=start, edge_lengths=nwrite)
  endif
  ! close the file
  if (close_the_file) then
    if (check_if_open(fileobj_write_field_dd)) call fms2_close_file(fileobj_write_field_dd)
    write_field_time_index=0
    if (allocated(file_dim_names)) deallocate(file_dim_names)
  endif
  nullify(data_tmp)
end subroutine write_field_2d_DD

!> This function uses the fms_io function write_data to write a 3-D domain-decomposed data field named "fieldname"
!! to the file "filename" in "write", "overwrite", or "append" mode. It should be called after create_file in the MOM
!! file write procedure.
subroutine write_field_3d_DD(filename, fieldname, data, mode, domain, hor_grid, z_grid, &
                             start_index, edge_lengths, time_level, time_units, scale, &
                             checksums, G, dG, GV, leave_file_open, units, longname)
  character(len=*), intent(in) :: filename !< The name of the file to read
  character(len=*), intent(in) :: fieldname !< The variable name of the data in the file
  real, target, dimension(:,:,:), intent(in) :: data !< The 1-dimensional data array to pass to read_data
  character(len=*), intent(in) :: mode !< "write", "overwrite", or "append"
  type(MOM_domain_type),intent(in) :: domain !< MOM domain attribute with the mpp_domain decomposition
  character(len=*), intent(in) :: hor_grid !< horizontal grid descriptor
  character(len=*), intent(in) :: z_grid !< vertical grid descriptor
  integer, dimension(1), optional, intent(in) :: start_index !< starting index of data buffer. Default is 1
  integer, dimension(1), optional, intent(in) :: edge_lengths !< number of data values to read in; default is
                                                              !! the variable size
  real, optional, intent(in) :: time_level !< time value to write
  real, optional, intent(in) :: time_units !< length of the units for time [s]. The
                                          !! default value is 86400.0, for 1 day.
  real, optional, intent(in) :: scale !< A scaling factor that the fields are multiplied by before they are written.
  integer(kind=8), dimension(:,:), optional, intent(in) :: checksums  !< variable checksum
  type(ocean_grid_type),   optional, intent(in) :: G !< ocean horizontal grid structure; G or dG
                                                     !! is required if the new file uses any
                                                     !! horizontal grid axes.
  type(dyn_horgrid_type),  optional, intent(in) :: dG !< dynamic horizontal grid structure; G or dG
                                                     !! is required if the new file uses any
                                                     !! horizontal grid axes.
  type(verticalGrid_type), optional, intent(in) :: GV !< ocean vertical grid structure, which is
                                                     !! required if the new file uses any
                                                     !! vertical grid axes.
  logical, optional, intent(in) :: leave_file_open !< flag indicating whether to leave the file open
  character(len=*), optional, intent(in) :: units !< variable units
  character(len=*), optional, intent(in) :: longname !< long name variable attribute
  ! local
  logical :: file_open_success !.true. if call to open_file is successful
  logical :: close_the_file ! indicates whether to close the file after write_data is called; default is .true.
  real, pointer, dimension(:,:,:) :: data_tmp => null() ! enables data to be passed to functions as intent(inout)
  integer :: i, is, ie, js, je, ndims, num_dims, substring_index
  integer :: dim_unlim_size ! size of the unlimited dimension
  integer, dimension(3) :: start, nwrite ! indices for first data value and number of values to write
  character(len=20) :: t_units ! time units
  character(len=nf90_max_name) :: dim_unlim_name ! name of the unlimited dimension in the file
  character(len=1024) :: filename_temp
  character(len=64) :: checksum_char ! checksum character array created from checksum argument
  character(len=48), dimension(4) :: dim_names !< variable dimension names; 1 extra dimension in case appending
                                               !! along the time axis
  integer, dimension(4) :: dim_lengths !< variable dimension lengths

  close_the_file = .true.
  if (present(leave_file_open)) close_the_file = .not.(leave_file_open)

  dim_unlim_size = 0
  dim_unlim_name = ""
  dim_names(:) = ""
  dim_lengths(:) = 0
  num_dims = 0
  ! append '.nc' to the file name if it is missing
  filename_temp = ""
  substring_index = 0
  substring_index = index(trim(filename), ".nc")
  if (substring_index <= 0) then
    filename_temp = append_substring(filename,".nc")
  else
    filename_temp = filename
  endif
  ! get the dimension names and lengths
  ! NOTE: the t_grid argument is set to '1' (do nothing) because the presence of a time dimension is user-specified
  ! and not assumed from the t_grid value
  if (present(G)) then
    call get_var_dimension_metadata(hor_grid, z_grid, '1', dim_names, &
                                    dim_lengths, num_dims, G=G)
  elseif(present(dG)) then
    call get_var_dimension_metadata(hor_grid, z_grid, '1', dim_names, &
                                    dim_lengths, num_dims, dG=dG)
  endif

  if (present(GV)) &
    call get_var_dimension_metadata(hor_grid, z_grid, '1', dim_names, &
                                    dim_lengths, num_dims, GV=GV)
  ! set the start (start_index) and nwrite (edge_lengths) values
  ndims = 3
  start(:) = 1
  nwrite(:) = dim_lengths(1:3)
  if (present(start_index)) then
    do i=1,ndims
      start(i) = max(1,start_index(i))
    enddo
  endif

  if (present(edge_lengths)) then
    do i=1,ndims
      nwrite(i) = max(dim_lengths(i), edge_lengths(i))
    enddo
  endif

  data_tmp => data
  ! scale the data
  if (present(scale)) then ; if (scale /= 1.0) then
    call scale_data(data_tmp,scale)
  endif ; endif
  ! open the file
  if (.not.(check_if_open(fileobj_write_field_dd))) then
    if ((lowercase(trim(mode)) .ne. "write") .and. (lowercase(trim(mode)) .ne. "append") .and. &
        (lowercase(trim(mode)) .ne. "overwrite")) &
      call MOM_error(FATAL,"MOM_write_field_fms2:write_3d_DD:mode argument must be write, overwrite, or append")
    ! define the io domain for 1-pe jobs because it is required to write domain-decomposed files
    if (mpp_get_domain_npes(domain%mpp_domain) .eq. 1 ) then
      if (.not. associated(mpp_get_io_domain(domain%mpp_domain))) &
        call mpp_define_io_domain(domain%mpp_domain, (/1,1/))
    endif
    ! get the time_level index
    if (present(time_level)) write_field_time_index = get_time_index(trim(filename_temp), time_level)
    ! open the file in write or append mode
    file_open_success = fms2_open_file(fileobj_write_field_dd, trim(filename_temp), lowercase(trim(mode)), &
                                       domain%mpp_domain, is_restart=.false.)
    ! register the horizontal and vertical diagnostic axes associated with the variable
    do i=1,ndims
      call MOM_register_diagnostic_axis(fileobj_write_field_dd, trim(dim_names(i)), dim_lengths(i))
    enddo
  endif
  ! register and write the time_level
  if (present(time_level)) then
    call get_unlimited_dimension_name(fileobj_write_field_dd ,dim_unlim_name)
    call get_dimension_size(fileobj_write_field_dd, trim(dim_unlim_name), dim_unlim_size)
    num_dims=num_dims+1
    dim_names(num_dims) = trim(dim_unlim_name)

    if (.not. (variable_exists(fileobj_write_field_dd, trim(dim_unlim_name)))) then
       ! set the time units
       t_units = ""
       if (present(time_units)) then
         t_units = get_time_units(time_units)
       else
         t_units = "days"
       endif

       call register_field(fileobj_write_field_dd, trim(dim_unlim_name), "double", dimensions=(/trim(dim_unlim_name)/))
       call register_variable_attribute(fileobj_write_field_dd, trim(dim_unlim_name), 'units', trim(t_units))
       call write_data(fileobj_write_field_dd, trim(dim_unlim_name), (/time_level/), corner=(/write_field_time_index/))
    else
      ! write the time_level if it is larger than the most recent file time
      if (write_field_time_index .gt. dim_unlim_size ) &
        call write_data(fileobj_write_field_dd, trim(dim_unlim_name), (/time_level/), &
                         corner=(/write_field_time_index/), edge_lengths=(/1/))
    endif
  endif
  ! register the field if it is not already in the file
  if (.not.(variable_exists(fileobj_write_field_dd, trim(fieldname)))) then
    call register_field(fileobj_write_field_dd, trim(fieldname), "double", dimensions=dim_names(1:num_dims))
    if (present(units)) &
      call register_variable_attribute(fileobj_write_field_dd, trim(fieldname), 'units', trim(units))
    if (present(longname)) &
      call register_variable_attribute(fileobj_write_field_dd, trim(fieldname), 'long_name', trim(longname))
    ! write the checksum attribute
    if (present(checksums)) then
      ! convert the checksum to a string
      checksum_char = ""
      checksum_char = convert_checksum_to_string(checksums(1,1))
      call register_variable_attribute(fileobj_write_field_dd, trim(fieldname), "checksum", checksum_char)
    endif
  endif
  ! write the data
  if (present(time_level)) then
    call get_dimension_size(fileobj_write_field_dd, trim(dim_unlim_name), dim_unlim_size)
    call write_data(fileobj_write_field_dd, trim(fieldname), data_tmp, corner=start, edge_lengths=nwrite, &
                    unlim_dim_level=write_field_time_index)
  else
    call write_data(fileobj_write_field_dd, trim(fieldname), data_tmp, corner=start, edge_lengths=nwrite)
  endif
  ! close the file
  if (close_the_file) then
    if (check_if_open(fileobj_write_field_dd)) call fms2_close_file(fileobj_write_field_dd)
    write_field_time_index=0
  endif
  nullify(data_tmp)

end subroutine write_field_3d_DD

!> This function uses the fms_io function write_data to write a 4-D domain-decomposed data field named "fieldname"
!! to the file "filename" in "write", "overwrite", or "append" mode. It should be called after create_file in the MOM
!! file write procedure.
subroutine write_field_4d_DD(filename, fieldname, data, mode, domain, hor_grid, z_grid, t_grid, &
                             start_index, edge_lengths, time_level, time_units, scale, &
                             checksums, G, dG, GV, leave_file_open, units, longname)
  character(len=*), intent(in) :: filename !< The name of the file to read
  character(len=*), intent(in) :: fieldname !< The variable name of the data in the file
  real, target, dimension(:,:,:,:), intent(in) :: data !< The 1-dimensional data array to pass to read_data
  character(len=*), intent(in) :: mode !< "write", "overwrite", or "append"
  type(MOM_domain_type),intent(in) :: domain !< MOM domain attribute with the mpp_domain decomposition
  character(len=*), intent(in) :: hor_grid !< horizontal grid descriptor
  character(len=*), intent(in) :: z_grid !< vertical grid descriptor
  character(len=*), intent(in) :: t_grid !< time descriptor
  integer, dimension(1), optional, intent(in) :: start_index !< starting index of data buffer. Default is 1
  integer, dimension(1), optional, intent(in) :: edge_lengths !< number of data values to read in; default is
                                                              !! the variable size
  real, optional, intent(in) :: time_level !< time value to write
  real, optional, intent(in) :: time_units !< length of the units for time [s]. The
                                          !! default value is 86400.0, for 1 day.
  real, optional, intent(in) :: scale !< A scaling factor that the fields are multiplied by before they are written.
   integer(kind=8), dimension(:,:), optional, intent(in) :: checksums  !< variable checksum
  type(ocean_grid_type),   optional, intent(in) :: G !< ocean horizontal grid structure; G or dG
                                                     !! is required if the new file uses any
                                                     !! horizontal grid axes.
  type(dyn_horgrid_type),  optional, intent(in) :: dG !< dynamic horizontal grid structure; G or dG
                                                     !! is required if the new file uses any
                                                     !! horizontal grid axes.
  type(verticalGrid_type), optional, intent(in) :: GV !< ocean vertical grid structure, which is
                                                     !! required if the new file uses any
                                                     !! vertical grid axes.
  logical, optional, intent(in) :: leave_file_open !< flag indicating whether to leave the file open
  character(len=*), optional, intent(in) :: units !< variable units
  character(len=*), optional, intent(in) :: longname !< long name variable attribute
  ! local
  logical :: file_open_success !.true. if call to open_file is successful
  logical :: close_the_file ! indicates whether to close the file after write_data is called; default is .true.
  real, pointer, dimension(:,:,:,:) :: data_tmp => null() ! enables data to be passed to functions as intent(inout)
  real :: file_time ! most recent time currently written to file
  integer :: i, ndims, num_dims, substring_index
  integer :: dim_unlim_size ! size of the unlimited dimension
  integer, dimension(4) :: start, nwrite ! indices for first data value and number of values to write
  character(len=20) :: t_units ! time units
  character(len=nf90_max_name) :: dim_unlim_name ! name of the unlimited dimension in the file
  character(len=1024) :: filename_temp
  character(len=64) :: checksum_char ! checksum character array created from checksum argument
  character(len=48), dimension(4) :: dim_names ! variable dimension names
  integer, dimension(4) :: dim_lengths ! variable dimension lengths

  close_the_file = .true.
  if (present(leave_file_open)) close_the_file = .not.(leave_file_open)

  num_dims = 0
  dim_unlim_size = 0
  dim_unlim_name = ""
  dim_names(:) = ""
  dim_lengths(:) = 0
  ! append '.nc' to the file name if it is missing
  filename_temp = ""
  substring_index = 0
  substring_index = index(trim(filename), ".nc")
  if (substring_index <= 0) then
    filename_temp = append_substring(filename,".nc")
  else
    filename_temp = filename
  endif
  ! get the dimension names and lengths
  if (present(G)) then
    call get_var_dimension_metadata(hor_grid, z_grid, t_grid, dim_names, &
                                    dim_lengths, num_dims, G=G)
  elseif(present(dG)) then
    call get_var_dimension_metadata(hor_grid, z_grid, t_grid, dim_names, &
                                    dim_lengths, num_dims, dG=dG)
  endif

  if (present(GV)) &
    call get_var_dimension_metadata(hor_grid, z_grid, t_grid, dim_names, &
                                    dim_lengths, num_dims, GV=GV)
  ! set the start (start_index) and nwrite (edge_lengths) values
  ndims = 4
  start(:) = 1
  nwrite(:) = dim_lengths(:)
  if (present(start_index)) then
    do i=1,ndims
      start(i) = max(1,start_index(i))
    enddo
  endif

  if (present(edge_lengths)) then
    do i=1,ndims
      nwrite(i) = max(dim_lengths(i), edge_lengths(i))
    enddo
  endif

  data_tmp => data
  ! scale the data
  if (present(scale)) then ; if (scale /= 1.0) then
    call scale_data(data_tmp,scale)
  endif ; endif
  ! open the file
  if (.not.(check_if_open(fileobj_write_field_dd))) then
    if ((lowercase(trim(mode)) .ne. "write") .and. (lowercase(trim(mode)) .ne. "append") .and. &
        (lowercase(trim(mode)) .ne. "overwrite")) &
      call MOM_error(FATAL,"MOM_write_field_fms2:write_4d_DD:mode argument must be write, overwrite, or append")
    ! define the io domain for 1-pe jobs because it is required to write domain-decomposed files
    if (mpp_get_domain_npes(domain%mpp_domain) .eq. 1 ) then
      if (.not. associated(mpp_get_io_domain(domain%mpp_domain))) &
        call mpp_define_io_domain(domain%mpp_domain, (/1,1/))
    endif
    ! get the index of the corresponding time_level the first time the file is opened
    if (present(time_level)) write_field_time_index = get_time_index(trim(filename_temp), time_level)
    ! open the file in write or append mode
    file_open_success = fms2_open_file(fileobj_write_field_dd, trim(filename_temp), lowercase(trim(mode)), &
                                       domain%mpp_domain, is_restart=.false.)
    ! register the horizontal and vertical diagnostic axes associated with the variable
    do i=1,ndims
      call MOM_register_diagnostic_axis(fileobj_write_field_dd, trim(dim_names(i)), dim_lengths(i))
    enddo
  endif
  ! register the time dimension and write the time_level
  if (present(time_level)) then
    call get_unlimited_dimension_name(fileobj_write_field_dd, dim_unlim_name)
    call get_dimension_size(fileobj_write_field_dd, trim(dim_unlim_name), dim_unlim_size)
    num_dims=num_dims+1
    dim_names(num_dims) = trim(dim_unlim_name)

    if (.not. (variable_exists(fileobj_write_field_dd, trim(dim_unlim_name)))) then
       ! set the time units
       t_units = ""
       if (present(time_units)) then
         t_units = get_time_units(time_units)
       else
         t_units = "days"
       endif

       call register_field(fileobj_write_field_dd, trim(dim_unlim_name), "double", dimensions=(/trim(dim_unlim_name)/))
       call register_variable_attribute(fileobj_write_field_dd, trim(dim_unlim_name), 'units', trim(t_units))
       call write_data(fileobj_write_field_dd, trim(dim_unlim_name), (/time_level/), corner=(/write_field_time_index/))
    else
      ! write the time_level if it is larger than the most recent file time
      if (write_field_time_index .gt. dim_unlim_size) &
        call write_data(fileobj_write_field_dd, trim(dim_unlim_name), (/time_level/), &
                        corner=(/write_field_time_index/), edge_lengths=(/1/))
    endif
  endif
  ! register the variable if it is not already in the file
  if (.not.(variable_exists(fileobj_write_field_dd, trim(fieldname)))) then
    call register_field(fileobj_write_field_dd, trim(fieldname), "double", dimensions=dim_names(1:num_dims))
    if (present(units)) &
      call register_variable_attribute(fileobj_write_field_dd, trim(fieldname), 'units', trim(units))
    if (present(longname)) &
      call register_variable_attribute(fileobj_write_field_dd, trim(fieldname), 'long_name', trim(longname))
    ! write the checksum attribute
    if (present(checksums)) then
      ! convert the checksum to a string
      checksum_char = ""
      checksum_char = convert_checksum_to_string(checksums(1,1))
      call register_variable_attribute(fileobj_write_field_dd, trim(fieldname), "checksum", checksum_char)
    endif
  endif
  ! write the data
  if (present(time_level)) then
    call get_dimension_size(fileobj_write_field_dd, trim(dim_unlim_name), dim_unlim_size)
    call write_data(fileobj_write_field_dd, trim(fieldname), data_tmp, corner=start, edge_lengths=nwrite, &
                    unlim_dim_level=write_field_time_index)
  else
    call write_data(fileobj_write_field_dd, trim(fieldname), data_tmp, corner=start, edge_lengths=nwrite)
  endif
  ! close the file
  if (close_the_file) then
    if (check_if_open(fileobj_write_field_dd)) call fms2_close_file(fileobj_write_field_dd)
    write_field_time_index=0
  endif
  nullify(data_tmp)
end subroutine write_field_4d_DD

!> This routine uses the fms_io function write_data to write a scalar variable named "fieldname"
!! to the file "filename" in "write", "overwrite", or "append" mode. It should be called after create_file in the MOM
!! file write procedure.
subroutine write_scalar(filename, fieldname, data, mode, time_level, time_units, leave_file_open, units, longname)
  character(len=*), intent(in) :: filename !< The name of the file to read
  character(len=*), intent(in) :: fieldname !< The variable name of the data in the file
  real, intent(in) :: data !< The 1-dimensional data array to pass to read_data
  character(len=*), intent(in) :: mode !< "write", "overwrite", or "append"
  real, optional, intent(in) :: time_level !< time value to write
  real, optional, intent(in) :: time_units !< length of the units for time [s]. The
                                          !! default value is 86400.0, for 1 day
  logical, optional, intent(in) :: leave_file_open !< flag indicating whether to leave the file open
  character(len=*), optional, intent(in) :: units !< variable units
  character(len=*), optional, intent(in) :: longname !< long name variable attribute
  ! local
  logical :: file_open_success !.true. if call to open_file is successful
  logical :: close_the_file ! indicates whether to close the file after write_data is called; default is .true.
  character(len=20) :: t_units ! time units
  character(len=nf90_max_name) :: dim_unlim_name ! name of the unlimited dimension in the file
  character(len=1024) :: filename_temp
  character(len=48), dimension(1) :: dim_names ! variable dimension names
  integer :: i, num_dims, substring_index
  integer :: dim_unlim_size ! size of the unlimited dimension
  real, allocatable, dimension(:) :: file_times
  integer, dimension(1) :: dim_lengths ! variable dimension lengths
  integer, allocatable, dimension(:) :: pelist ! list of pes associated with the netCDF file

  dim_unlim_size = 0
  dim_unlim_name= ""
  dim_names(:) = ""
  dim_lengths(:) = 0
  num_dims = 0

  close_the_file = .true.
  if (present(leave_file_open)) close_the_file = .not.(leave_file_open)

  ! append '.nc' to the file name if it is missing
  filename_temp = ""
  substring_index = 0
  substring_index = index(trim(filename), ".nc")
  if (substring_index <= 0) then
    filename_temp = append_substring(filename,".nc")
  else
    filename_temp = filename
  endif

  if (.not.(check_if_open(fileobj_write_field))) then
    if ((lowercase(trim(mode)) .ne. "write") .and. (lowercase(trim(mode)) .ne. "append") .and. &
        (lowercase(trim(mode)) .ne. "overwrite")) &
      call MOM_error(FATAL,"MOM_write_field_fms2:write_scaler:mode argument must be write, overwrite, or append")
    ! get the index of the corresponding time_level the first time the file is opened
    if (present(time_level)) write_field_time_index = get_time_index(trim(filename_temp), time_level)
    ! get the pes associated with the file.
    !>\note this is required so that only pe(1) is identified as the root pe to create the file
    !! Otherwise, multiple pes may try to open the file in write (NC_NOCLOBBER) mode, leading to failure
    if (.not.(allocated(pelist))) then
      allocate(pelist(mpp_npes()))
      pelist(:) = 0
      do i=1,size(pelist)
        pelist(i) = i-1
      enddo
    endif
    ! open the file in write or append mode
    file_open_success = fms2_open_file(fileobj_write_field, trim(filename_temp), trim(mode), is_restart=.false., &
                                       pelist=pelist)
  endif
  if (present(time_level)) then
    call get_unlimited_dimension_name(fileobj_write_field, dim_unlim_name)
    call get_dimension_size(fileobj_write_field, trim(dim_unlim_name), dim_unlim_size)
    ! write the time value if it is not already written to the file
    if (.not.(variable_exists(fileobj_write_field, trim(dim_unlim_name)))) then
      ! set the time units
      t_units = ""
      if (present(time_units)) then
        t_units = get_time_units(time_units)
      else
        t_units = "days"
      endif

      call register_field(fileobj_write_field, trim(dim_unlim_name), "double", dimensions=(/trim(dim_unlim_name)/))
      call register_variable_attribute(fileobj_write_field, trim(dim_unlim_name), 'units', trim(t_units))
      call write_data(fileobj_write_field, trim(dim_unlim_name), (/time_level/))
    else
      ! write the next time value if it is larger than the most recent file time
      if (write_field_time_index .gt. dim_unlim_size) &
        call write_data(fileobj_write_field, trim(dim_unlim_name), (/time_level/), corner=(/write_field_time_index/), &
                        edge_lengths=(/1/))
    endif
  endif
  ! register the variable
  if (.not.(variable_exists(fileobj_write_field, trim(fieldname)))) then
    if (present(time_level)) then
      call register_field(fileobj_write_field, trim(fieldname), "double", dimensions=(/trim(dim_unlim_name)/))
    else
      call register_field(fileobj_write_field, trim(fieldname), "double")
    endif
    if (present(units)) &
      call register_variable_attribute(fileobj_write_field, trim(fieldname), 'units', trim(units))
    if (present(longname)) &
      call register_variable_attribute(fileobj_write_field, trim(fieldname), 'long_name', trim(longname))
  endif
  ! write the data
  if (present(time_level)) then
    call write_data(fileobj_write_field, trim(fieldname), data, unlim_dim_level=write_field_time_index)
  else
    call write_data(fileobj_write_field, trim(fieldname), data)
  endif
  ! close the file
  if (close_the_file) then
    if (check_if_open(fileobj_write_field)) call fms2_close_file(fileobj_write_field)
    if (allocated(pelist)) deallocate(pelist)
    write_field_time_index=0
  endif
end subroutine write_scalar

!> This function uses the fms_io function write_data to write a 1-D non-domain-decomposed data field named "fieldname"
!! to the file "filename" in "write", "overwrite", or "append" mode. It should be called after create_file in the MOM
!! file write procedure.
subroutine write_field_1d_noDD(filename, fieldname, data, mode, hor_grid, z_grid, &
                             start_index, edge_lengths, time_level, time_units, scale, &
                             checksums, G, dG, GV, leave_file_open, units, longname)
  character(len=*), intent(in) :: filename !< The name of the file to read
  character(len=*), intent(in) :: fieldname !< The variable name of the data in the file
  real, target, dimension(:), intent(in) :: data !< The 1-dimensional data array to pass to read_data
  character(len=*), intent(in) :: mode !< "write", "overwrite", or "append"
  character(len=*), intent(in) :: hor_grid !< horizontal grid descriptor
  character(len=*), intent(in) :: z_grid !< vertical grid descriptor
  integer, dimension(1), optional, intent(in) :: start_index !< starting index of data buffer. Default is 1
  integer, dimension(1), optional, intent(in) :: edge_lengths !< number of data values to read in; default is the
                                                          !! variable size
  real, optional, intent(in) :: time_level !< time value to write
  real, optional, intent(in) :: time_units !< length of the units for time [s]. The
                                          !! default value is 86400.0, for 1 day.
  real, optional, intent(in) :: scale !< A scaling factor that the fields are multiplied by before they are written.
  integer(kind=8), dimension(:,:), optional, intent(in) :: checksums  !< variable checksum
  type(ocean_grid_type),   optional, intent(in) :: G !< ocean horizontal grid structure; G or dG
                                                     !! is required if the new file uses any
                                                     !! horizontal grid axes.
  type(dyn_horgrid_type),  optional, intent(in) :: dG !< dynamic horizontal grid structure; G or dG
                                                     !! is required if the new file uses any
                                                     !! horizontal grid axes.
  type(verticalGrid_type), optional, intent(in) :: GV !< ocean vertical grid structure, which is
                                                     !! required if the new file uses any
                                                     !! vertical grid axes.
  logical, optional, intent(in) :: leave_file_open !< if .true., leave file open
  character(len=*), optional, intent(in) :: units !< variable units
  character(len=*), optional, intent(in) :: longname !< long name variable attribute
  ! local
  logical :: file_open_success !.true. if call to open_file is successful
  real, pointer, dimension(:) :: data_tmp => null() ! enables data to be passed to functions as intent(inout)
  integer :: i, ndims, num_dims, substring_index
  integer :: dim_unlim_size ! size of the unlimited dimension
  integer, dimension(1) :: start, nwrite ! indices for first data value and number of values to write
  character(len=20) :: t_units ! time units
  character(len=nf90_max_name) :: dim_unlim_name ! name of the unlimited dimension in the file
  character(len=1024) :: filename_temp
  character(len=64) :: checksum_char ! checksum character array created from checksum argument
  character(len=48), dimension(2) :: dim_names ! variable dimension names (up to 2 if appended at time level)
  integer, dimension(2) :: dim_lengths ! variable dimension lengths
  integer, allocatable, dimension(:) :: pelist ! list of pes associated with the netCDF file
  logical :: close_the_file ! indicates whether to close the file after write_data is called; default is .true.

  close_the_file = .true.
  if (present(leave_file_open)) close_the_file = .not.(leave_file_open)

  dim_unlim_size = 0
  dim_unlim_name= "Time"
  dim_names(:) = ""
  dim_lengths(:) = 0
  num_dims = 0

  ! append '.nc' to the file name if it is missing
  filename_temp = ""
  substring_index = 0
  substring_index = index(trim(filename), ".nc")
  if (substring_index <= 0) then
    filename_temp = append_substring(filename,".nc")
  else
    filename_temp = filename
  endif
  ! get the dimension names and lengths
  ! NOTE: the t_grid argument is set to '1' (do nothing) because the presence of a time dimension is user-specified
  ! and not assumed from the t_grid value.
  if (present(G)) then
    call get_var_dimension_metadata(hor_grid, z_grid, '1', dim_names, &
                                    dim_lengths, num_dims, G=G)
  elseif(present(dG)) then
    call get_var_dimension_metadata(hor_grid, z_grid, '1', dim_names, &
                                    dim_lengths, num_dims, dG=dG)
  endif

  if (present(GV)) &
    call get_var_dimension_metadata(hor_grid, z_grid, '1', dim_names, &
                                    dim_lengths, num_dims, GV=GV)
  ! set the start (start_index) and nwrite (edge_lengths) values
  start(:) = 1
  nwrite(:) = dim_lengths(1)
  if (present(start_index)) then
    start(1) = max(1,start_index(1))
  endif

  if (present(edge_lengths)) then
    nwrite(1) = max(dim_lengths(1),edge_lengths(1))
  endif

  data_tmp => data
  ! scale the data
  if (present(scale)) then ; if (scale /= 1.0) then
    call scale_data(data_tmp,scale)
  endif ; endif

  if (.not.(check_if_open(fileobj_write_field))) then
    if ((lowercase(trim(mode)) .ne. "write") .and. (lowercase(trim(mode)) .ne. "append") .and. &
       (lowercase(trim(mode)) .ne. "overwrite")) &
      call MOM_error(FATAL,"MOM_write_field_fms2:write_1d_noDD:mode argument must be write, overwrite, or append")
    ! get the index of the corresponding time_level the first time the file is opened
    if (present(time_level)) write_field_time_index = get_time_index(trim(filename_temp), time_level)
    ! get the pes associated with the file.
    !>\note this is required so that only pe(1) is identified as the root pe to create the file
    !! Otherwise, multiple pes may try to open the file in write (NC_NOCLOBBER) mode, leading to failure
    if (.not.(allocated(pelist))) then
      allocate(pelist(mpp_npes()))
      pelist(:) = 0
      do i=1,size(pelist)
        pelist(i) = i-1
      enddo
    endif
    ! open the file in write or append mode
    file_open_success = fms2_open_file(fileobj_write_field, trim(filename_temp), lowercase(trim(mode)), &
                                       is_restart=.false., pelist=pelist)
  endif
  ! write the data, and the time value if it is not already written to the file
  if (present(time_level)) then
    call get_unlimited_dimension_name(fileobj_write_field,dim_unlim_name)
    call get_dimension_size(fileobj_write_field, trim(dim_unlim_name), dim_unlim_size)
    num_dims=num_dims+1
    dim_names(num_dims) = trim(dim_unlim_name)

    if (.not. (variable_exists(fileobj_write_field, trim(dim_unlim_name)))) then
       ! set the time units
       t_units = ""
       if (present(time_units)) then
         t_units = get_time_units(time_units)
       else
         t_units = "days"
       endif

       call register_field(fileobj_write_field, trim(dim_unlim_name), "double", dimensions=(/trim(dim_unlim_name)/))
       call register_variable_attribute(fileobj_write_field, trim(dim_unlim_name), 'units', trim(t_units))
      call write_data(fileobj_write_field, trim(dim_unlim_name), (/time_level/), corner=(/write_field_time_index/))
    else
      ! write the time value if it is larger than the most recent file time
      if (write_field_time_index .gt. dim_unlim_size) &
        call write_data(fileobj_write_field, trim(dim_unlim_name), (/time_level/), corner=(/write_field_time_index/), &
                        edge_lengths=(/1/))
    endif
  endif
  ! register the field if it is not already in the file
  if (.not.(variable_exists(fileobj_write_field, trim(fieldname)))) then
    call register_field(fileobj_write_field, trim(fieldname), "double", dimensions=dim_names(1:num_dims))
    if (present(units)) &
      call register_variable_attribute(fileobj_write_field, trim(fieldname), 'units', trim(units))
    if (present(longname)) &
      call register_variable_attribute(fileobj_write_field, trim(fieldname), 'long_name', trim(longname))
    ! write the checksum attribute
    if (present(checksums)) then
    ! convert the checksum to a string
      checksum_char = ''
      checksum_char = convert_checksum_to_string(checksums(1,1))
      call register_variable_attribute(fileobj_write_field, trim(fieldname), "checksum", checksum_char)
    endif
  endif
  ! write the variable to the file
  if (present(time_level)) then
    call write_data(fileobj_write_field, trim(fieldname), data_tmp, corner=start, edge_lengths=nwrite, &
                    unlim_dim_level=write_field_time_index)
  else
    call write_data(fileobj_write_field, trim(fieldname), data_tmp, corner=start, edge_lengths=nwrite)
  endif
  ! close the file
  if (close_the_file) then
    if (check_if_open(fileobj_write_field)) call fms2_close_file(fileobj_write_field)
    if (allocated(pelist)) deallocate(pelist)
    write_field_time_index = 0
  endif
  nullify(data_tmp)

end subroutine write_field_1d_noDD

!> This function uses the fms_io function write_data to write a scalar variable named "fieldname"
!! to the file "filename" in "write", "overwrite", or "append" mode. It should be called after create_file in the MOM
!! file write procedure.
subroutine write_field_2d_noDD(filename, fieldname, data, mode, hor_grid, z_grid, &
                             start_index, edge_lengths, time_level, time_units, scale, &
                             checksums, G, dG, GV, leave_file_open, units, longname)
  character(len=*), intent(in) :: filename !< The name of the file to read
  character(len=*), intent(in) :: fieldname !< The variable name of the data in the file
  real, target, dimension(:,:), intent(in) :: data !< The 2-dimensional data array to pass to read_data
  character(len=*), intent(in) :: mode !< "write", "overwrite", or "append"
  character(len=*), intent(in) :: hor_grid !< horizontal grid descriptor
  character(len=*), intent(in) :: z_grid !< vertical grid descriptor
  integer, dimension(2), optional, intent(in) :: start_index !< starting index of data buffer. Default is 1
  integer, dimension(2), optional, intent(in) :: edge_lengths !< number of data values to read in; default is the
                                                          !! variable size
  real, optional, intent(in) :: time_level !< time value to write
  real, optional, intent(in) :: time_units !< length of the units for time [s]. The
                                          !! default value is 86400.0, for 1 day.
  real, optional, intent(in) :: scale !< A scaling factor that the fields are multiplied by before they are written.
  integer(kind=8), dimension(:,:), optional, intent(in) :: checksums  !< variable checksum
  type(ocean_grid_type),   optional, intent(in) :: G !< ocean horizontal grid structure; G or dG
                                                     !! is required if the new file uses any
                                                     !! horizontal grid axes.
  type(dyn_horgrid_type),  optional, intent(in) :: dG !< dynamic horizontal grid structure; G or dG
                                                     !! is required if the new file uses any
                                                     !! horizontal grid axes.
  type(verticalGrid_type), optional, intent(in) :: GV !< ocean vertical grid structure, which is
                                                     !! required if the new file uses any
                                                     !! vertical grid axes.
  logical, optional, intent(in) :: leave_file_open !< flag indicating whether to leave the file open
  character(len=*), optional, intent(in) :: units !< variable units
  character(len=*), optional, intent(in) :: longname !< long name variable attribute
  ! local
  logical :: file_open_success ! .true. if call to open_file is successful
  logical :: close_the_file ! indicates whether to close the file after write_data is called; default is .true.
  real, pointer, dimension (:,:) :: data_tmp => null() ! enables data to be passed to functions as intent(inout)
  integer :: i, ndims, num_dims, substring_index
  integer :: dim_unlim_size ! size of the unlimited dimension
  integer, dimension(2) :: start, nwrite ! indices for starting points and number of values to write
  character(len=20) :: t_units ! time units
  character(len=nf90_max_name) :: dim_unlim_name ! name of the unlimited dimension in the file
  character(len=1024) :: filename_temp
  character(len=64) :: checksum_char ! checksum character array created from checksum argument
  character(len=48), dimension(3) :: dim_names ! variable dimension names
  integer, dimension(3) :: dim_lengths ! variable dimension lengths
  integer, allocatable, dimension(:) :: pelist ! list of pes associated with the netCDF file

  close_the_file = .true.
  if (present(leave_file_open)) close_the_file = .not.(leave_file_open)

  dim_unlim_size = 0
  dim_unlim_name = ""
  dim_names(:) = ""
  dim_lengths(:) = 0
  num_dims = 0

  ! append '.nc' to the file name if it is missing
  filename_temp = ""
  substring_index = 0
  substring_index = index(trim(filename), ".nc")
  if (substring_index <= 0) then
    filename_temp = append_substring(filename,".nc")
  else
    filename_temp = filename
  endif

  ! get the dimension names and lengths
  ! NOTE: the t_grid argument is set to '1' (do nothing) because the presence of a time dimension is user-specified
  ! and not assumed from the t_grid value
  if (present(G)) then
    call get_var_dimension_metadata(hor_grid, z_grid, '1', dim_names, &
                                    dim_lengths, num_dims, G=G)
  elseif(present(dG)) then
    call get_var_dimension_metadata(hor_grid, z_grid, '1', dim_names, &
                                    dim_lengths, num_dims, dG=dG)
  endif

  if (present(GV)) &
    call get_var_dimension_metadata(hor_grid, z_grid, '1', dim_names, &
                                      dim_lengths, num_dims, GV=GV)

  ! set the start (start_index) and nwrite (edge_lengths) values
  ndims=2
  start(:) = 1
  nwrite(:) = dim_lengths(1:2)
  if (present(start_index)) then
    do i=1,ndims
      start(i) = max(1,start_index(i))
    enddo
  endif

  if (present(edge_lengths)) then
    do i=1,ndims
      nwrite(i) = max(dim_lengths(i),edge_lengths(i))
    enddo
  endif

  data_tmp => data
  ! scale the data
  if (present(scale)) then ; if (scale /= 1.0) then
    call scale_data(data_tmp,scale)
  endif ; endif

  if (.not.(check_if_open(fileobj_write_field))) then
    if ((lowercase(trim(mode)) .ne. "write") .and. (lowercase(trim(mode)) .ne. "append") .and. &
        (lowercase(trim(mode)) .ne. "overwrite")) &
      call MOM_error(FATAL,"MOM_write_field_fms2:write_2d_noDD:mode argument must be write, overwrite, or append")
    ! get the time_level index
    if (present(time_level)) write_field_time_index = get_time_index(trim(filename_temp), time_level)
    ! get the pes associated with the file.
    !>\note this is required so that only pe(1) is identified as the root pe to create the file
    !! Otherwise, multiple pes may try to open the file in write (NC_NOCLOBBER) mode, leading to failure
    if(.not.(allocated(pelist))) then
      allocate(pelist(mpp_npes()))
      pelist(:) = 0
      do i=1,size(pelist)
        pelist(i) = i-1
      enddo
    endif
    ! open the file in write or append mode
    file_open_success = fms2_open_file(fileobj_write_field, trim(filename_temp), lowercase(trim(mode)), &
                                       is_restart=.false., pelist=pelist)
  endif

  if (present(time_level)) then
    call get_unlimited_dimension_name(fileobj_write_field,dim_unlim_name)
    call get_dimension_size(fileobj_write_field, trim(dim_unlim_name), dim_unlim_size)
    num_dims=num_dims+1
    dim_names(num_dims) = trim(dim_unlim_name)

    if (.not. (variable_exists(fileobj_write_field, trim(dim_unlim_name)))) then
       ! set the time units
       t_units = ""
       if (present(time_units)) then
         t_units = get_time_units(time_units)
       else
         t_units = "days"
       endif

       call register_field(fileobj_write_field, trim(dim_unlim_name), "double", dimensions=(/trim(dim_unlim_name)/))
       call register_variable_attribute(fileobj_write_field, trim(dim_unlim_name), 'units', trim(t_units))
      call write_data(fileobj_write_field, trim(dim_unlim_name), (/time_level/), corner=(/write_field_time_index/))
    else
      ! write the time value if it is larger than the most recent file time
      if (write_field_time_index .gt. dim_unlim_size) &
        call write_data(fileobj_write_field, trim(dim_unlim_name), (/time_level/), corner=(/write_field_time_index/), &
                        edge_lengths=(/1/))
    endif
  endif

   ! register the variable to the file
  if (.not.(variable_exists(fileobj_write_field, trim(fieldname)))) then
    call register_field(fileobj_write_field, trim(fieldname), "double", dimensions=dim_names(1:num_dims))
    if (present(units)) &
      call register_variable_attribute(fileobj_write_field, trim(fieldname), 'units', trim(units))
    if (present(longname)) &
      call register_variable_attribute(fileobj_write_field, trim(fieldname), 'long_name', trim(longname))
    ! write the checksum attribute
    if (present(checksums)) then
      ! convert the checksum to a string
      checksum_char = ""
      checksum_char = convert_checksum_to_string(checksums(1,1))
      call register_variable_attribute(fileobj_write_field, trim(fieldname), "checksum", checksum_char)
    endif
  endif
  ! write the variable to the file
  if (present(time_level)) then
    call write_data(fileobj_write_field, trim(fieldname), data_tmp, corner=start, edge_lengths=nwrite, &
                    unlim_dim_level=write_field_time_index)
  else
    call write_data(fileobj_write_field, trim(fieldname), data_tmp, corner=start, edge_lengths=nwrite)
  endif
  ! close the file
  if (close_the_file) then
    if (check_if_open(fileobj_write_field)) call fms2_close_file(fileobj_write_field)
    if (allocated(pelist)) deallocate(pelist)
    write_field_time_index=0
  endif
  nullify(data_tmp)
end subroutine write_field_2d_noDD

!> This function uses the fms_io function write_data to write a 3-D non-domain-decomposed data field named "fieldname"
!! to the file "filename" in "write", "overwrite", or "append" mode. It should be called after create_file in the MOM
!! file write procedure.
subroutine write_field_3d_noDD(filename, fieldname, data, mode, hor_grid, z_grid, &
                             start_index, edge_lengths, time_level, time_units, scale, &
                             checksums, G, dG, GV, leave_file_open, units, longname)
  character(len=*), intent(in) :: filename !< The name of the file to read
  character(len=*), intent(in) :: fieldname !< The variable name of the data in the file
  real, target, dimension(:,:,:), intent(in) :: data !< The 3-dimensional data array to pass to read_data
  character(len=*), intent(in) :: mode !< "write", "overwrite", or "append"
  character(len=*), intent(in) :: hor_grid !< horizontal grid descriptor
  character(len=*), intent(in) :: z_grid !< vertical grid descriptor
  integer, dimension(4), optional, intent(in) :: start_index !< starting index of data buffer. Default is 1
  integer, dimension(4), optional, intent(in) :: edge_lengths !< number of data values to read in; default is the
                                                          !! variable size
  real, optional, intent(in) :: time_level !< time value to write
  real, optional, intent(in) :: time_units !< length of the units for time [s]. The
                                          !! default value is 86400.0, for 1 day.
  real, optional, intent(in) :: scale !< A scaling factor that the fields are multiplied by before they are written.
  integer(kind=8), dimension(:,:), optional, intent(in) :: checksums  !< variable checksum
  type(ocean_grid_type),   optional, intent(in) :: G !< ocean horizontal grid structure; G or dG
                                                     !! is required if the new file uses any
                                                     !! horizontal grid axes.
  type(dyn_horgrid_type),  optional, intent(in) :: dG !< dynamic horizontal grid structure; G or dG
                                                     !! is required if the new file uses any
                                                     !! horizontal grid axes.
  type(verticalGrid_type), optional, intent(in) :: GV !< ocean vertical grid structure, which is
                                                     !! required if the new file uses any
                                                     !! vertical grid axes.
  logical, optional, intent(in) :: leave_file_open !< flag indicating whether to leave the file open
  character(len=*), optional, intent(in) :: units !< variable units
  character(len=*), optional, intent(in) :: longname !< long name variable attribute
  ! local
  logical :: file_open_success !.true. if call to open_file is successful
  logical :: close_the_file ! indicates whether to close the file after write_data is called; default is .true.
  real, pointer, dimension(:,:,:) :: data_tmp => null() ! enables data to be passed to functions as intent(inout)
  integer :: i, ndims, num_dims, substring_index
  integer :: dim_unlim_size ! size of the unlimited dimension
  integer, dimension(3) :: start, nwrite ! indices for first data value and number of values to write
  character(len=20) :: t_units ! time_units
  character(len=nf90_max_name) :: dim_unlim_name ! name of the unlimited dimension in the file
  character(len=1024) :: filename_temp
  character(len=64) :: checksum_char ! checksum character array created from checksum argument
  character(len=48), dimension(4) :: dim_names ! variable dimension names
  integer, dimension(4) :: dim_lengths ! variable dimension lengths
  integer, allocatable, dimension(:) :: pelist ! list of pes associated with the netCDF file

  close_the_file = .true.
  if (present(leave_file_open)) close_the_file = .not.(leave_file_open)

  dim_unlim_size = 0
  dim_unlim_name = ""
  dim_names(:) = ""
  dim_lengths(:) = 0
  num_dims = 0
  ! append '.nc' to the file name if it is missing
  filename_temp = ""
  substring_index = 0
  substring_index = index(trim(filename), ".nc")
  if (substring_index <= 0) then
    filename_temp = append_substring(filename,".nc")
  else
    filename_temp = filename
  endif
  ! get the dimension names and lengths
  ! NOTE: the t_grid argument is set to '1' (do nothing) because the presence of a time dimension is user-specified
  ! and not assumed from the t_grid value
  if (present(G)) then
    call get_var_dimension_metadata(hor_grid, z_grid, '1', dim_names, &
                                    dim_lengths, num_dims, G=G)
  elseif(present(dG)) then
    call get_var_dimension_metadata(hor_grid, z_grid, '1', dim_names, &
                                    dim_lengths, num_dims, dG=dG)
  endif

  if (present(GV)) &
    call get_var_dimension_metadata(hor_grid, z_grid, '1', dim_names, &
                                    dim_lengths, num_dims, GV=GV)
  ! set the start (start_index) and nwrite (edge_lengths) values
  ndims = 3
  start(:) = 1
  nwrite(:) = dim_lengths(1:3)
  if (present(start_index)) then
    do i=1,ndims
      start(i) = max(1,start_index(i))
    enddo
  endif

  if (present(edge_lengths)) then
    do i=1,ndims
      nwrite(i) = max(dim_lengths(i), edge_lengths(i))
    enddo
  endif

  data_tmp => data
  ! scale the data
  if (present(scale)) then ; if (scale /= 1.0) then
    call scale_data(data_tmp,scale)
  endif ; endif
  ! open the file
  if (.not.(check_if_open(fileobj_write_field))) then
    if ((lowercase(trim(mode)) .ne. "write") .and. (lowercase(trim(mode)) .ne. "append") .and. &
        (lowercase(trim(mode)) .ne. "overwrite")) &
      call MOM_error(FATAL,"MOM_io:write_3d_noDD:mode argument must be write, overwrite, or append")
    ! get the time_level index
    if (present(time_level))  write_field_time_index = get_time_index(trim(filename_temp), time_level)
    ! get the pes associated with the file.
    !>\note this is required so that only pe(1) is identified as the root pe to create the file
    !! Otherwise, multiple pes may try to open the file in write (NC_NOCLOBBER) mode, leading to failure
    if (.not.(allocated(pelist))) then
      allocate(pelist(mpp_npes()))
      pelist(:) = 0
      do i=1,size(pelist)
        pelist(i) = i-1
      enddo
    endif
    ! open the file in write or append mode
    file_open_success = fms2_open_file(fileobj_write_field, trim(filename_temp), lowercase(trim(mode)), &
                                       is_restart=.false., pelist=pelist)
  endif
  ! register and write the time_level
  if (present(time_level)) then
    call get_unlimited_dimension_name(fileobj_write_field,dim_unlim_name)
    call get_dimension_size(fileobj_write_field, trim(dim_unlim_name), dim_unlim_size)
    num_dims=num_dims+1
    dim_names(num_dims) = trim(dim_unlim_name)

    if (.not. (variable_exists(fileobj_write_field, trim(dim_unlim_name)))) then
       ! set the time units
       t_units = ""
       if (present(time_units)) then
         t_units = get_time_units(time_units)
       else
         t_units = "days"
       endif

       call register_field(fileobj_write_field, trim(dim_unlim_name), "double", dimensions=(/trim(dim_unlim_name)/))
       call register_variable_attribute(fileobj_write_field, trim(dim_unlim_name), 'units', trim(t_units))
       call write_data(fileobj_write_field, trim(dim_unlim_name), (/time_level/), corner=(/write_field_time_index/))
    else
      ! write the time_level if it is larger than the most recent file time
      if (write_field_time_index .gt. dim_unlim_size) &
        call write_data(fileobj_write_field, trim(dim_unlim_name), (/time_level/), corner=(/write_field_time_index/), &
                        edge_lengths=(/1/))
    endif
  endif
  ! register the field if it is not already in the file
  if (.not.(variable_exists(fileobj_write_field, trim(fieldname)))) then
    call register_field(fileobj_write_field, trim(fieldname), "double", dimensions=dim_names(1:num_dims))
    if (present(units)) &
      call register_variable_attribute(fileobj_write_field, trim(fieldname), 'units', trim(units))
    if (present(longname)) &
      call register_variable_attribute(fileobj_write_field, trim(fieldname), 'long_name', trim(longname))
    ! write the checksum attribute
    if (present(checksums)) then
      ! convert the checksum to a string
      checksum_char = ""
      checksum_char = convert_checksum_to_string(checksums(1,1))
      call register_variable_attribute(fileobj_write_field, trim(fieldname), "checksum", checksum_char)
    endif
  endif

  if (present(time_level)) then
    call get_dimension_size(fileobj_write_field, trim(dim_unlim_name), dim_unlim_size)
    call write_data(fileobj_write_field, trim(fieldname), data_tmp, corner=start, edge_lengths=nwrite, &
                    unlim_dim_level=write_field_time_index)
  else
    call write_data(fileobj_write_field, trim(fieldname), data_tmp, corner=start, edge_lengths=nwrite)
  endif
  ! close the file
  if (close_the_file) then
    if (check_if_open(fileobj_write_field)) call fms2_close_file(fileobj_write_field)
    if (allocated(pelist)) deallocate(pelist)
    write_field_time_index=0
  endif
  nullify(data_tmp)
end subroutine write_field_3d_noDD

!> This function uses the fms_io function write_data to write a 4-D non-domain-decomposed data field named "fieldname"
!! to the file "filename" in "write", "overwrite", or "append" mode. It should be called after create_file in the MOM
!! file write procedure.
subroutine write_field_4d_noDD(filename, fieldname, data, mode, hor_grid, z_grid, t_grid, &
                             start_index, edge_lengths, time_level, time_units, scale, &
                             checksums, G, dG, GV, leave_file_open, units, longname)
  character(len=*), intent(in) :: filename !< The name of the file to read
  character(len=*), intent(in) :: fieldname !< The variable name of the data in the file
  real, target, dimension(:,:,:,:), intent(in) :: data !< The 1-dimensional data array to pass to read_data
  character(len=*), intent(in) :: mode !< "write", "overwrite", or "append"
  character(len=*), intent(in) :: hor_grid !< horizontal grid descriptor
  character(len=*), intent(in) :: z_grid !< vertical grid descriptor
  character(len=*), intent(in) :: t_grid !< time descriptor
  integer, dimension(4), optional, intent(in) :: start_index !< starting index of data buffer. Default is 1
  integer, dimension(4), optional, intent(in) :: edge_lengths !< number of data values to read in; default is the
                                                          !! variable size
  real, optional, intent(in) :: time_level !< time value to write
  real, optional, intent(in) :: time_units !< length of the units for time [s]. The
                                          !! default value is 86400.0, for 1 day.
  real, optional, intent(in) :: scale !< A scaling factor that the fields are multiplied by before they are written.
  integer(kind=8), dimension(:,:), optional, intent(in) :: checksums  !< variable checksum
  type(ocean_grid_type),   optional, intent(in) :: G !< ocean horizontal grid structure; G or dG
                                                     !! is required if the new file uses any
                                                     !! horizontal grid axes.
  type(dyn_horgrid_type),  optional, intent(in) :: dG !< dynamic horizontal grid structure; G or dG
                                                     !! is required if the new file uses any
                                                     !! horizontal grid axes.
  type(verticalGrid_type), optional, intent(in) :: GV !< ocean vertical grid structure, which is
                                                     !! required if the new file uses any
                                                     !! vertical grid axes.
  logical, optional, intent(in) :: leave_file_open !< flag indicating whether to leave the file open
  character(len=*), optional, intent(in) :: units !< variable units
  character(len=*), optional, intent(in) :: longname !< long name variable attribute
  ! local
  logical :: file_open_success !.true. if call to open_file is successful
  logical :: close_the_file ! indicates whether to close the file after write_data is called; default is .true.
  real, pointer, dimension(:,:,:,:) :: data_tmp => null() ! enables data to be passed to functions as intent(inout)
  integer :: i, ndims, num_dims, substring_index
  integer :: dim_unlim_size ! size of the unlimited dimension
  integer, dimension(4) :: start, nwrite ! indices for first data value and number of values to write
  character(len=20) :: t_units ! time units
  character(len=nf90_max_name) :: dim_unlim_name ! name of the unlimited dimension in the file
  character(len=1024) :: filename_temp
  character(len=64) :: checksum_char ! checksum character array created from checksum argument
  character(len=48), dimension(4) :: dim_names ! variable dimension names
  integer, dimension(4) :: dim_lengths ! variable dimension lengths
  integer, allocatable, dimension(:) :: pelist ! list of pes associated with the netCDF file

  close_the_file = .true.
  if (present(leave_file_open)) close_the_file = .not.(leave_file_open)

  dim_unlim_size = 0
  dim_unlim_name = ""
  dim_names(:) = ""
  dim_lengths(:) = 0
  ndims = 4
  num_dims = 0
  ! append '.nc' to the file name if it is missing
  filename_temp = ""
  substring_index = 0
  substring_index = index(trim(filename), ".nc")
  if (substring_index <= 0) then
    filename_temp = append_substring(filename,".nc")
  else
    filename_temp = filename
  endif

  ! get the dimension names and lengths
  if (present(G)) then
    call get_var_dimension_metadata(hor_grid, z_grid, t_grid, dim_names, &
                                    dim_lengths, num_dims, G=G)
  elseif(present(dG)) then
    call get_var_dimension_metadata(hor_grid, z_grid, t_grid, dim_names, &
                                    dim_lengths, num_dims, dG=dG)
  endif
  if (present(GV)) &
    call get_var_dimension_metadata(hor_grid, z_grid, t_grid, dim_names, &
                                    dim_lengths, num_dims, GV=GV)
  ! set the start (start_index) and nwrite (edge_lengths) values
  start(:) = 1
  nwrite(:) = dim_lengths(:)
  if (present(start_index)) then
    do i=1,ndims
      start(i) = max(1, start_index(i))
    enddo
  endif

  if (present(edge_lengths)) then
    do i=1,ndims
      nwrite(i) = max(dim_lengths(i), edge_lengths(i))
    enddo
  endif

  data_tmp => data
  ! scale the data
  if (present(scale)) then ; if (scale /= 1.0) then
    call scale_data(data_tmp,scale)
  endif ; endif
  ! open the file
  if (.not.(check_if_open(fileobj_write_field))) then
    if ((lowercase(trim(mode)) .ne. "write") .and. (lowercase(trim(mode)) .ne. "append") .and. &
        (lowercase(trim(mode)) .ne. "overwrite")) &
      call MOM_error(FATAL,"MOM_write_field_fms2:write_4d_noDD:mode argument must be write, overwrite, or append")
    ! get the time_level index
    if (present(time_level)) write_field_time_index = get_time_index(trim(filename_temp), time_level)
    ! get the pes associated with the file.
    !>\note this is required so that only pe(1) is identified as the root pe to create the file
    !! Otherwise, multiple pes may try to open the file in write (NC_NOCLOBBER) mode, leading to failure
    if (.not.(allocated(pelist))) then
      allocate(pelist(mpp_npes()))
      pelist(:) = 0
      do i=1,size(pelist)
        pelist(i) = i-1
      enddo
    endif
    ! open the file in write or append mode
    file_open_success = fms2_open_file(fileobj_write_field, trim(filename_temp), lowercase(trim(mode)), &
                                       is_restart=.false., pelist=pelist)
  endif
  ! register and write the time_level
  if (present(time_level)) then
    call get_unlimited_dimension_name(fileobj_write_field,dim_unlim_name)
    call get_dimension_size(fileobj_write_field, trim(dim_unlim_name), dim_unlim_size)
    num_dims=num_dims+1
    dim_names(num_dims) = trim(dim_unlim_name)
    ! write the time value if it is not already written to the file
    if (.not. (variable_exists(fileobj_write_field, trim(dim_unlim_name)))) then
       ! set the time units
       t_units = ""
       if (present(time_units)) then
         t_units = get_time_units(time_units)
       else
         t_units = "days"
       endif

       call register_field(fileobj_write_field, trim(dim_unlim_name), "double", dimensions=(/trim(dim_unlim_name)/))
       call register_variable_attribute(fileobj_write_field, trim(dim_unlim_name), 'units', trim(t_units))
       call write_data(fileobj_write_field, trim(dim_unlim_name), (/time_level/), corner=(/write_field_time_index/))
    else
      if (write_field_time_index .gt. dim_unlim_size) &
        call write_data(fileobj_write_field, trim(dim_unlim_name), (/time_level/), corner=(/write_field_time_index/), &
                        edge_lengths=(/1/))
    endif
  endif
  ! register the variable
  if (.not.(variable_exists(fileobj_write_field, trim(fieldname)))) then
     call register_field(fileobj_write_field, trim(fieldname), "double", dimensions=dim_names(1:num_dims))
     if (present(units)) &
       call register_variable_attribute(fileobj_write_field, trim(fieldname), 'units', trim(units))
     if (present(longname)) &
       call register_variable_attribute(fileobj_write_field, trim(fieldname), 'long_name', trim(longname))
     ! write the checksum attribute
     if (present(checksums)) then
       ! convert the checksum to a string
       checksum_char = ""
       checksum_char = convert_checksum_to_string(checksums(1,1))
      call register_variable_attribute(fileobj_write_field, trim(fieldname), "checksum", checksum_char)
     endif
  endif
  ! write the variable to the file
  if (present(time_level)) then
    call write_data(fileobj_write_field, trim(fieldname), data_tmp, corner=start, edge_lengths=nwrite, &
                    unlim_dim_level=write_field_time_index)
  else
    call write_data(fileobj_write_field, trim(fieldname), data_tmp, corner=start, edge_lengths=nwrite)
  endif
  ! close the file
  if (close_the_file) then
    if (check_if_open(fileobj_write_field)) call fms2_close_file(fileobj_write_field)
    deallocate(pelist)
    write_field_time_index=0
  endif
  nullify(data_tmp)
end subroutine write_field_4d_nodd

!> apply a scale factor to a 1d array
subroutine scale_data_1d(data, scale_factor)
  real, dimension(:), intent(inout) :: data !< The 1-dimensional data array
  real, intent(in) :: scale_factor !< Scale factor

  if (scale_factor /= 1.0) then
    data(:) = scale_factor*data(:)
  endif
end subroutine scale_data_1d

!> apply a scale factor to a 2d array
subroutine scale_data_2d(data, scale_factor, MOM_domain)
  real, dimension(:,:), intent(inout) :: data !< The 2-dimensional data array
  real, intent(in) :: scale_factor !< Scale factor
  type(MOM_domain_type), optional, intent(in) :: MOM_Domain !< The domain that describes the decomposition
  ! local
  integer :: is, ie, js, je

  if (scale_factor /= 1.0) then
    if (present(MOM_domain)) then
      call get_simple_array_i_ind(MOM_Domain, size(data,1), is, ie)
      call get_simple_array_j_ind(MOM_Domain, size(data,2), js, je)
      data(is:ie,js:je) = scale_factor*data(is:ie,js:je)
    else
      data(:,:) = scale_factor*data(:,:)
    endif
  endif
end subroutine scale_data_2d

!> apply a scale factor to a 3d array
subroutine scale_data_3d(data, scale_factor, MOM_domain)
  real, dimension(:,:,:), intent(inout) :: data !< The 3-dimensional data array
  real, intent(in) :: scale_factor !< Scale factor
  type(MOM_domain_type), optional, intent(in) :: MOM_Domain !< The domain that describes the decomposition
  ! local
  integer :: is, ie, js, je

  if (scale_factor /= 1.0) then
    if (present(MOM_domain)) then
      call get_simple_array_i_ind(MOM_Domain, size(data,1), is, ie)
      call get_simple_array_j_ind(MOM_Domain, size(data,2), js, je)
      data(is:ie,js:je,:) = scale_factor*data(is:ie,js:je,:)
    else
      data(:,:,:) = scale_factor*data(:,:,:)
    endif
  endif
end subroutine scale_data_3d

!> apply a scale factor to a 4d array
subroutine scale_data_4d(data, scale_factor, MOM_domain)
  real, dimension(:,:,:,:), intent(inout) :: data !< The 4-dimensional data array
  real, intent(in) :: scale_factor !< Scale factor
  type(MOM_domain_type), optional, intent(in) :: MOM_Domain !< The domain that describes the decomposition
  ! local
  integer :: is, ie, js, je

  if (scale_factor /= 1.0) then
    if (present(MOM_domain)) then
      call get_simple_array_i_ind(MOM_Domain, size(data,1), is, ie)
      call get_simple_array_j_ind(MOM_Domain, size(data,2), js, je)
      data(is:ie,js:je,:,:) = scale_factor*data(is:ie,js:je,:,:)
    else
      data(:,:,:,:) = scale_factor*data(:,:,:,:)
    endif
  endif
end subroutine scale_data_4d


end module MOM_write_field_fms2
